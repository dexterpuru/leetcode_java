/**
 * Definition for singly-linked list.
 * public class ListNode {
 *     int val;
 *     ListNode next;
 *     ListNode() {}
 *     ListNode(int val) { this.val = val; }
 *     ListNode(int val, ListNode next) { this.val = val; this.next = next; }
 * }
 */
class Solution {
    
    //Iterative solution
    /*
        public ListNode deleteDuplicates(ListNode head) {

            if(head == null || head.next == null) return head;

            Set<Integer> visited = new HashSet<>();
            Set<Integer> duplicates = new HashSet<>();

            ListNode pointer = head;

            while(pointer != null){
                if(visited.contains(pointer.val)){
                    duplicates.add(pointer.val);
                }
                visited.add(pointer.val);
                pointer = pointer.next;
            }

            pointer = head;
            ListNode prev = head;

            while(pointer != null){
                if(duplicates.contains(pointer.val)){
                    if(pointer == head){
                        head = head.next;
                        pointer = head;
                        prev = head;
                    }else{
                        prev.next = pointer.next;
                        pointer = pointer.next;
                    }
                }else{
                    prev = pointer;
                    pointer = pointer.next;
                }
            }

            return head;
        }
        
    */
    
    //Recursive solution(better)
    //This uses the fact that any duplicates element is 
    public ListNode deleteDuplicates(ListNode head){
        
        if(head == null || head.next == null) return head;
        
        //two adjacent values are uniques
        if(head.val != head.next.val){
            head.next = deleteDuplicates(head.next);
            return head;
        }
        
        ListNode pointer = head;
        //Will check until we get the unique value
        while(pointer != null && pointer.val == head.val){
            pointer = pointer.next;
        }
        
        return deleteDuplicates(pointer);
    }
}